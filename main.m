%% DegreeDayDA: Degree-Day snow model with Data Assimilation
% 
% This script can be used to demonstrate or explore data assimilation (DA).
% It sets up an Ensemble Smoother (ES) or Ensemble Smoother with Multi Data
% Assimilation (ES-MDA) in a synthetic experiment, i.e. the observations
% used in the assimulation are generated by the model. 
% 
% We use a very simple model, a degree day model, to simulate the evolution
% of the snowpack through one hydrological year. A degree day model takes
% daily temperature (in degrees Celsius) and precipitation (in mm/day) as
% inputs to simulate the evolution of the snow water equivalent (SWE). Snow
% accumulation is diagnosed using a fixed (assumed known) threshold
% temperature for snowfall and by applying a snowfall multiplier (uncertain
% parameter) to the precipitation to account for potential biases and
% unresolved proceses like snowdrift. Snow ablation is diagnosed for
% positive degree days (days with a temperature > 0 degrees Celsius) by
% scaling positive temperatures with a degree-day factor (uncertain
% parameter) which parametrizes all the unresolved processes related to
% snowmelt and sublimation. We model the evolution of the snow depth (in mm
% w.e.) in a number of grid
% 
% The idea in a synthetic experiment is to:
% 
%   1) Perform a so-called "truth run" by setting some true value for the
%   parameters in the respective grid cells. For the rest of the experiment
%   (other than the validation), we pretend that we don't know the true
%   values of the two parameters (degree day factor, snowfall multiplier)
%   and states (SWE) other than in the final validation. 
%   2) Generate synthetic observations by perturbing the true SWE for a
%   subset of days in the truth runs to mimic reality with sparse and
%   imperfect observations.
%   3) Set a prior distribution on the uncertain parameters (remember, we
%   wouldn't know the truth in practice) and run an ensemble of degree-day
%   models for the entire water year with different values for the two
%   parameters.
%   4) Assimilate the synthetic observations at the end of the water year
%   to update the parameters. Then rerun the water year with the posterior
%   (updated) parameters to get the posterior SWE.
%   5) Perform some validation, i.e. compare the prior and posterior to the
%   truth, to see if the assimilation is working as intended. Potentially
%   compare the effect of using different: (i) Assimilation schemes, (ii)
%   Observation errors, (iii) Observation density, (iv) Observation types,
%   (v) Snow models, (vi) Localization routines.    



% points close to Finse, Norway. We use real climatic forcing from
% down-scaled weather data TopoSCALE


% THINGS TO DO TO IMPROVE CODE
% make it possible to define global parameter, a model parameter that is
% the same for the entire model domaine, and local parameter, a model
% parameter that can vary from grid point to grid point

% make it possible to define observations per grid point / location

% rename variables:
% a = ddf
% b = precip_factor or Pfactor
% D = snowdepth
% here = obs_t

%% start code

clearvars;

% set parameters

% t_start     = '01-Sep-2018'
% t_end       = '01-Sep-2019'

% truth run & synthetic observations
ysd         = 20; % standard deviation of the error term added to the synthetic SWE observations
atrue       = [6; 6];%6; % mm/d/K
btrue       = [0.5; 2];
tobs        = [datenum('01-Jan-2019'); datenum('01-Feb-2019');...
                datenum('01-Mar-2019'); datenum('01-Apr-2019');...
                datenum('01-May-2019'); datenum('01-Jun-2019');...
                datenum('01-Jul-2019'); datenum('01-Aug-2019')];
% Data assimilation parameters
Ne          = 1e2; % ensemble size 
Na          = 4;   % number of MDA iterations


% literature value for the ddf for snow 2.5 to 11.6 mm/d/K



%% load climatic forcing

% load real-data forcing
load('TopoSCALE.mat');   % contains weather data for two grid points 
f.P=double(f.P).*f.P_sf; % unpack precipitation data
f.T=double(f.T).*f.T_sf; % unpack temperature data


% select model period and define model time t
t=datenum('01-Sep-2018'):1:datenum('01-Sep-2019'); t=t';

% translate hourly values into daily values
Nt=numel(t);
P=zeros(Nt,2);
T=P;
for j=1:Nt
   here=f.t>t(j)&f.t<=(t(j)+1);
   T(j,:)=mean(f.T(:,here),2);
   P(j,:)=sum(f.P(:,here),2); 
end


%% 1) Synthetic model run creating the 'TRUTH' 
%D=zeros(size(P));
% run the degree day model for defined period, climate input, and model
% parameters
D = DDM(t,P,T,atrue,btrue);
% set result to truth 
Dtrue=D;

%% 2) Generate synthetic observations 
% add observation error to truth
Dobs=Dtrue+ysd.*randn(size(Dtrue));
Dobs=max(Dobs,0); % Observed SWE can not be negative


% and select observations by defining the time (=day) of observation
No=numel(tobs);
tmp=zeros(No,2);
here=zeros(Nt,1,'logical');
for j=1:No
    herej=t==tobs(j);
    here=here+herej;
    tmp(j,:)=Dobs(herej,:);
end
here=logical(here);
Dobs=tmp;

%{
figure(1); clf;
plot(t,D);
datetick('x','keepticks','keeplimits');
hold on;
scatter(tobs,Dobs,150,'.');
%}


%% 3) Set a prior distribution on the uncertain parameters
a=exp(log(5)+1.*randn(2,Ne));
b=exp(log(1)+1.*randn(2,Ne));


%% 4) Run the model and assimilate the synthetic observations 

% run the data assimilation Na times (user-defined number of MDA
% iterations), and run the model one more time to calculate the model
% result with the final parameter ensembles (Na+1)
for ell=1:(Na+1)    
    % model run
    D=DDM(t,P,T,a,b);
    
    % Data Assimilation
    theta=[a;b];    % theta combines all parameters that can be updated
    
    % save ensemble prior and post (ensembles before and after the
    % assimilation(s), the intermediate results in MDA are not saved)
    if ell==1
        thetapri=theta;
        apri=a(1:2,:);
        bpri=b(1:2,:);
        Dpri=D;
    elseif ell==(Na+1)
        thetapost=theta;
        apost=a(1:2,:);
        bpost=b(1:2,:);
        Dpost=D;
    end
    
    % peform data assimilation; except for the Na+1 iteration
    if ell<=Na
        % perform anamorphosis on the parameters to assure Gaussian
        % distribution
        phi=log(theta);
        % define the model predicted observations matrix from the model results
        Yp=D(here,:,:); % time, space, ensemble
        Yp=reshape(Yp,No*2,Ne);
        % define the observation matrix
        y=Dobs;
        y=y(:);
        % define observation covariance (measure for observation
        % uncertainty
        R=ysd.^2;
        alpha=Na; % number of MDA iterations
        pert_stat=1; % 1 for MDA, 0 for ES
        % update parameters with the EnKA function
        phi=EnKA(phi,Yp,y,R,alpha,pert_stat);
        % transform parameters back
        theta=exp(phi);
        % update model parameters
        a=theta(1:2,:);
        b=theta(3:4,:);
    end
end

%return

%% 5) Perform some validation

figure(1); clf;
for loc=1:2
    subplot(2,2,loc);
    plot(t,squeeze(Dpri(:,loc,:)),'LineWidth',0.5,'Color',[0.8 0 0 0.1]); hold on;
    plot(t,squeeze(Dpost(:,loc,:)),'LineWidth',0.5,'Color',[0 0 0.8 0.1]); hold on;
    pt(1)=plot(t,squeeze(mean(Dpri(:,loc,:),3)),'LineWidth',2,'Color',[0.8 0 0 1]); hold on;
    pt(2)=plot(t,squeeze(mean(Dpost(:,loc,:),3)),'LineWidth',2,'Color',[0 0 0.8 1]); hold on;
    Dtl=Dtrue(:,loc);
    pt(3)=plot(t,Dtl,'-k','LineWidth',2);
    pt(4)=scatter(tobs,Dobs(:,loc),100,'o','MarkerFaceColor',[0.7 0.7 0],'MarkerEdgeColor',[0 0 0]);
    %scatter(tobs,Dobs(:,loc),250,'.','MarkerEdgeColor',[0 0 0]);
    leg=legend(pt(:),{'Prior','Post','Truth','Obs'},'Interpreter','Latex',...
        'FontSize',16,'Location','NorthWest');
    clear pt;
    yl=5*max(Dtl); 
    ylim([0 2e3]);
    xlim([min(t) max(t)]);
    datetick('x','keepticks','keeplimits');
    axis xy;
    ylabel('SWE [mm]','Interpreter','Latex','FontSize',20);
    box on; %grid on;
    set(gca,'TickDir','out','LineWidth',1.5,'TickLength',[0.005, 0.005]);
    set(groot, 'defaultAxesTickLabelInterpreter','Latex');
    set(gca,'TickLabelInterpreter','latex'); 
    title(sprintf('States in location %d',loc),'Interpreter','Latex','FontSize',16);
    
    subplot(2,2,2+loc);
    xpri=apri(loc,:); ypri=bpri(loc,:);
    alphis=0.4;
    pt(1)=scatter(xpri,ypri,4e1,'o','MarkerFaceColor',[0.8 0 0],'MarkerFaceAlpha',alphis,...
        'MarkerEdgeColor',[0 0 0]); hold on;
    xpost=apost(loc,:); ypost=bpost(loc,:);
    pt(2)=scatter(xpost,ypost,4e1,'s','MarkerFaceColor',[0 0 0.8],'MarkerFaceAlpha',alphis,...
        'MarkerEdgeColor',[0 0 0]); 
    pt(3)=scatter(atrue(loc),btrue(loc),250,'p','MarkerEdgeColor',[0 0 0],'LineWidth',2,...
        'MarkerFaceColor',[1 1 1]);
    leg=legend(pt(:),{'Prior','Post','Truth'},'Interpreter','Latex',...
        'FontSize',16,'Location','NorthEast');
    clear pt;
    xlim([0 30]);
    ylim([0 5]);
    axis xy;
    ylabel('Snowfall multiplier, $b$ [-]','Interpreter','Latex','FontSize',20);
    xlabel('Degree-day factor, $a$ [mm/K/d]','Interpreter','Latex','FontSize',20);
    box on; %grid on;
    set(gca,'TickDir','out','LineWidth',1.5,'TickLength',[0.005, 0.005]);
    set(groot, 'defaultAxesTickLabelInterpreter','Latex');
    set(gca,'TickLabelInterpreter','latex'); 
    axis square;
    title(sprintf('Parameters in location %d',loc),'Interpreter','Latex','FontSize',16);
end

% print('-djpeg','results','-r300','-opengl');